// Uya语言完整测试套件
extern i32 printf(byte* fmt, ...);

// 1. 基本类型和变量
fn test_basic_types() void {
    let x: i32 = 42;
    let mut y: i32 = 10;
    y = y + 5;
    
    let f: f64 = 3.14159;
    let b: bool = true;
    
    printf("基本类型测试: x=%d, y=%d, f=%f, b=%s\n", 
           x, y, f, if b { "true" } else { "false" });
}

// 2. 结构体测试
struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

fn test_structs() void {
    let v: Vec3 = Vec3{ x: 1.0, y: 2.0, z: 3.0 };
    printf("结构体测试: Vec3(%.1f, %.1f, %.1f)\n", v.x, v.y, v.z);
}

// 3. 数组和切片测试
fn test_arrays_and_slices() void {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];
    printf("原数组: ");
    for (iter(&arr)) |val| {
        printf("%d ", val);
    }
    printf("\n");
    
    // 测试切片
    let slice1: [i32; 3] = slice(arr, 1, 4);  // [2, 3, 4]
    printf("切片 arr[1:4]: ");
    for (iter(&slice1)) |val| {
        printf("%d ", val);
    }
    printf("\n");
    
    // 测试负数索引切片
    let slice2: [i32; 2] = slice(arr, -2, 5);  // [4, 5]
    printf("负数索引切片 arr[-2:5]: ");
    for (iter(&slice2)) |val| {
        printf("%d ", val);
    }
    printf("\n");
}

// 4. 错误处理测试
error CustomError;
error AnotherError;

fn may_fail(flag: bool) !i32 {
    if flag {
        return 42;
    } else {
        return error.CustomError;
    }
}

fn test_error_handling() void {
    printf("错误处理测试:\n");
    
    // 成功路径
    let success_val: i32 = try may_fail(true);
    printf("  成功: %d\n", success_val);
    
    // 错误路径
    let err_val: i32 = may_fail(false) catch |err| {
        if err == error.CustomError {
            printf("  捕获预期错误\n");
        }
        return 0;
    };
}

// 5. 控制流测试
fn test_control_flow() void {
    printf("控制流测试:\n");
    
    // if语句
    let x: i32 = 10;
    if x > 5 {
        printf("  x > 5\n");
    } else {
        printf("  x <= 5\n");
    }
    
    // while循环
    let mut i: i32 = 0;
    while i < 3 {
        printf("  while循环: %d\n", i);
        i = i + 1;
    }
    
    // for循环
    let nums: [i32; 3] = [10, 20, 30];
    for (iter(&nums)) |num| {
        printf("  for循环: %d\n", num);
    }
}

// 6. 函数和类型转换测试
fn add(a: i32, b: i32) i32 {
    return a + b;
}

fn test_functions() void {
    let result: i32 = add(5, 7);
    printf("函数调用测试: 5 + 7 = %d\n", result);
}

// 7. 接口测试
interface IWriter {
    fn write(self: *Self, data: byte*) i32;
}

struct ConsoleWriter {
    fd: i32
}

impl ConsoleWriter : IWriter {
    fn write(self: *Self, data: byte*) i32 {
        // 简化实现，实际应调用系统write函数
        printf("ConsoleWriter: %s\n", data);
        return len(data);
    }
}

fn test_interface() void {
    printf("接口测试:\n");
    let writer: ConsoleWriter = ConsoleWriter{ fd: 1 };
    // writer.write("Hello from interface");
}

// 8. 原子类型测试
struct AtomicCounter {
    value: atomic i32
}

fn test_atomic() void {
    printf("原子类型测试:\n");
    let mut counter: AtomicCounter = AtomicCounter{ value: 0 };
    
    // 原子操作
    counter.value += 1;  // 自动原子fetch_add
    counter.value += 1;
    
    let val: i32 = counter.value;  // 自动原子load
    printf("  原子计数器值: %d\n", val);
}

// 9. defer/errdefer测试
fn test_defer_errdefer() !void {
    printf("defer/errdefer测试:\n");
    
    defer {
        printf("  defer: 函数结束时执行\n");
    }
    
    errdefer {
        printf("  errdefer: 错误时执行\n");
    }
    
    printf("  函数主体执行\n");
    
    // 模拟成功情况
    return;
}

// 10. 字符串插值测试（如果支持）
fn test_string_interpolation() void {
    let x: i32 = 42;
    let pi: f64 = 3.14159;
    
    printf("字符串插值测试: x=%d, pi=%.2f\n", x, pi);
}

// 11. 泛型测试（如果支持）
fn id(val: T) T {
    return val;
}

fn test_generic() void {
    let int_val: i32 = id(123);
    let str_val: byte* = id("generic");
    
    printf("泛型测试: id(123)=%d, id(\"generic\")=%s\n", int_val, str_val);
}

// 12. 宏测试（如果支持）
mc twice(x: i32) expr { x + x }

fn test_macro() void {
    let x: i32 = 5;
    let result: i32 = twice(x);  // 展开为 x + x
    
    printf("宏测试: twice(5) = %d\n", result);
}

fn main() i32 {
    printf("=== Uya语言完整功能测试 ===\n\n");
    
    test_basic_types();
    printf("\n");
    
    test_structs();
    printf("\n");
    
    test_arrays_and_slices();
    printf("\n");
    
    test_error_handling();
    printf("\n");
    
    test_control_flow();
    printf("\n");
    
    test_functions();
    printf("\n");
    
    test_interface();
    printf("\n");
    
    test_atomic();
    printf("\n");
    
    test_defer_errdefer() catch |err| {
        printf("defer测试中发生错误\n");
    };
    printf("\n");
    
    test_string_interpolation();
    printf("\n");
    
    test_generic();
    printf("\n");
    
    test_macro();
    printf("\n");
    
    printf("=== 所有测试完成 ===\n");
    
    return 0;
}