---
name: 模块系统实现
overview: 在 uya.md 中添加模块系统（v1.4）的完整实现规范，包括目录级模块、export 导出、use 导入（支持路径和别名），遵循 Uya 零新关键字的设计哲学（复用现有关键字）。
todos:
  - id: add_module_chapter
    content: 在 uya.md 中添加新的模块系统章节，包含设计目标、语法、语义和示例
    status: pending
  - id: update_keywords
    content: 更新关键字列表，添加 export、use、mod（如果尚未包含）
    status: pending
  - id: update_file_lexical
    content: 更新文件与词法章节，添加模块相关的说明
    status: pending
  - id: update_future_section
    content: 更新未实现/将来章节，将模块系统标记为已实现
    status: pending
  - id: add_examples
    content: 添加完整的模块系统使用示例（多文件、导出、导入、别名等）
    status: pending
    dependencies:
      - add_module_chapter
---

# 模块系统实现（v1.4）

## 概述

在 `uya.md` 中添加新的章节，描述模块系统的完整实现。模块系统遵循 Uya 语言的设计哲学：

- **目录级模块**：每个目录自动成为一个模块
- **显式导出**：使用 `export` 关键字标记可导出的项
- **路径导入**：使用 `use` 关键字和路径语法导入模块
- **零运行时开销**：所有模块解析在编译期完成

## 实现内容

### 1. 新增章节位置

在 `uya.md` 中添加新章节，建议位置：

- 在"## 1 文件与词法"之后，或
- 在"## 28 未实现/将来"之前作为新章节

### 2. 章节结构

新章节应包含以下部分：

#### 2.1 设计目标

- 目录级模块系统
- 显式导出机制
- 路径式导入
- 编译期解析，零运行时开销

#### 2.2 模块定义

- 每个目录自动成为一个模块
- 模块名默认为目录名
- **模块路径基准**：模块路径相对于 **项目根目录**（包含 `main` 函数的目录）计算
- 项目根目录是模块系统的根
- 所有模块路径都相对于项目根目录解析
- **根目录模块**：项目根目录本身是一个特殊模块，模块名为 `main`
- 项目根目录是包含 `main` 函数的目录
- 项目根目录下的所有 `.uya` 文件都属于 `main` 模块
- 使用：`use main.some_function;` 或 `use main;`
- **子目录模块**：目录路径（相对于项目根目录）直接映射到模块路径
- 项目根目录下的 `std/io/` → 模块路径 `std.io`
- 项目根目录下的 `math/utils/` → 模块路径 `math.utils`
- 目录下的所有 `.uya` 文件都属于同一个模块
- **v1.4 限制**：不支持 `mod` 关键字（块级模块），仅支持目录级模块，符合零新关键字哲学

#### 2.3 导出机制

- 使用 `export` 关键字标记可导出的项
- 语法：`export fn`, `export struct`, `export interface`, `export const`, `export error`
- **FFI 导出**：
- `export extern` 用于导出 C FFI 函数：`export extern i32 printf(byte* fmt, ...);`
- `export extern` 用于导出 C 结构体（如果支持）：`export extern struct CStruct { ... };`
- **FFI 结构体类型限制**：
  - FFI 导出的结构体字段类型必须为 C 兼容类型（`i8`, `i16`, `i32`, `i64`, `u8`, `u16`, `u32`, `u64`, `f32`, `f64`, `bool`, `byte*`）
  - 不支持嵌套结构体、接口、错误联合类型等非 C 兼容类型
  - 确保运行时/ABI 兼容性
- 导出后，其他模块可以通过 `use` 导入并使用这些 FFI 函数/结构体
- 未标记 `export` 的项仅在模块内可见
- **为什么使用 `export` 而不是 `pub`**：
- `export` 语义更明确，专门用于模块导出
- `pub` 通常表示"公开可见性"（public vs private），概念更通用
- Uya 选择 `export` 以强调模块间的导出关系，语义更清晰

#### 2.4 导入机制

- 使用 `use` 关键字导入模块
- 路径语法：`use math.utils;` 或 `use math.utils.add;`
- 支持别名：`use math.utils as math_utils;`
- **v1.4 限制**：不支持通配符导入（`use math.*;`），避免命名污染和可读性下降
- **模块间引用规则**：
- 根目录模块（main）可以引用子目录模块：`use std.io;`
- 子目录模块可以引用其他子目录模块：`use std.io;`
- **子目录引用 main 模块的处理方式**（参考 Zig 的设计）：
- **方案 1：允许但检测循环依赖**（推荐，类似 Zig）：
    - 允许子目录模块引用 main 模块：`use main.helper;`
    - 编译器在编译期检测循环依赖并报错
    - 程序员需要手动打破循环（将共享功能提取到独立模块）
    - 示例：如果 `main.uya` 引用 `std.io`，`std.io` 引用 `main.helper`，编译器检测到循环并报错
- **方案 2：禁止子目录引用 main**（更严格）：
    - 禁止子目录模块引用 main 模块：`use main.helper;` → ❌ 编译错误
    - 如果子目录需要访问 main 的功能，应该将共享功能提取到独立的子目录模块中
    - 替代方案：将 `helper` 提取到 `common/helper.uya`，然后 `use common.helper;`
- 所有模块引用都是显式的，需要通过 `use` 导入
- **导入后的使用方式**：
  - **导入整个模块**：`use main;` 或 `use std.io;`
    - 使用模块中的导出项时，需要加上模块名前缀：`main.helper_func()` 或 `std.io.read_file()`
    - 示例：
      ```uya
      use main;
      use std.io;
      
      fn example() void {
          main.helper_func();      // 调用 main 模块的函数
          let file: std.io.File = std.io.open_file("test.txt");  // 使用 std.io 模块的结构体
      }
      ```
  - **导入特定项**：`use main.helper_func;` 或 `use std.io.read_file;`
    - 导入后可以直接使用，无需模块名前缀
    - 示例：
      ```uya
      use main.helper_func;
      use std.io.read_file;
      use std.io.File;
      
      fn example() void {
          helper_func();           // 直接调用，无需 main. 前缀
          let file: File = read_file("test.txt");  // 直接使用，无需 std.io. 前缀
      }
      ```
  - **导入结构体/接口**：`use std.io.File;` 或 `use std.io.IWriter;`
    - 导入后可以直接使用类型名，无需模块名前缀
    - 示例：
      ```uya
      use std.io.File;
      use std.io.IWriter;
      
      fn example() void {
          let f: File = File{ fd: 1 };  // 直接使用 File 类型
          let w: IWriter = ...;         // 直接使用 IWriter 接口
      }
      ```
  - **使用别名导入**：`use std.io as io;`
    - 使用别名时，需要用别名作为前缀
    - 示例：
      ```uya
      use std.io as io;
      
      fn example() void {
          io.read_file("test.txt");     // 使用别名 io 作为前缀
          let f: io.File = io.File{ fd: 1 };
      }
      ```
  - **混合使用**：可以同时导入整个模块和特定项
    - 示例：
      ```uya
      use main;                    // 导入整个 main 模块
      use main.helper_func;       // 同时导入特定函数（可以直接使用）
      
      fn example() void {
          helper_func();           // 直接使用（来自特定导入）
          main.other_func();       // 使用模块前缀（来自整体导入）
      }
      ```

#### 2.5 模块路径

- **路径基准**：所有模块路径相对于 **项目根目录**（包含 `main` 函数的目录）计算
- **根目录**：特殊模块名 `main`
- 项目根目录是包含 `main` 函数的目录
- 项目根目录下的文件 → `main` 模块
- 示例：`use main.helper;` 或 `use main;`
- **子目录**：目录路径（相对于项目根目录）直接映射到模块路径（目录分隔符 `/` 转换为 `.`）
- 项目根目录下的 `std/io/` → 模块路径 `std.io`
- 项目根目录下的 `math/utils/` → 模块路径 `math.utils`
- 使用：`use std.io;` 或 `use std.io.read_file;`
- 使用 `.` 分隔路径段
- **路径解析规则**：
- 编译器在项目根目录中查找模块
- 模块路径 `std.io` 对应项目根目录下的 `std/io/` 目录
- 所有模块引用都相对于项目根目录解析

#### 2.6 完整示例

- 多文件模块示例
- 导出/导入示例
- 别名使用示例
- **FFI 导出/导入示例**：
- 在模块中导出 FFI 函数：`export extern i32 printf(byte* fmt, ...);`
- 在其他模块中导入并使用：`use std.io.printf;`
- FFI 结构体的导出和导入（如果支持）

#### 2.7 项目根目录说明

- **项目根目录识别**：模块系统的根目录是包含 `fn main() i32` 函数的目录
- **自动识别逻辑**：
  - 编译器扫描所有源文件，找到包含 `fn main() i32` 的文件
  - 该文件所在的最顶层目录即为项目根目录
  - 示例：如果 `project/src/main.uya` 包含 `fn main() i32`，则 `project/src/` 是项目根目录
- **v1.4 限制**：不支持显式指定项目根目录（如通过 `-root` 编译选项），未来版本可能支持
- 所有模块路径都相对于项目根目录计算
- 编译器在项目根目录中查找和解析模块
- 项目根目录本身是 `main` 模块
- **路径解析**：
- `use std.io;` 在项目根目录下查找 `std/io/` 目录
- `use main.helper;` 在项目根目录下查找 `helper.uya` 文件
- 所有模块引用都相对于项目根目录解析（绝对相对于项目根目录）
- **多入口项目说明**：
  - 如果项目中有多个 `fn main() i32`，编译器会报错，要求明确项目根目录
  - 测试/工具等应作为独立的子目录模块，不包含 `main` 函数
- **项目结构示例**：
  ```javascript
    project/                 (项目根目录，包含 main 函数)
      main.uya               (main 模块，包含 fn main() i32)
      helper.uya             (main 模块)
      std/
        io/
          file.uya           (std.io 模块)
      math/
        utils/
          calc.uya           (math.utils 模块)
  ```




#### 2.8 限制和说明

- **循环依赖处理**（参考 Zig 的设计）：
- **允许子目录引用 main，但检测循环依赖**：
    - 允许 `use main.xxx;` 在子目录中使用
    - 编译器在编译期构建依赖图，检测强连通分量（循环依赖）
    - **循环依赖是编译错误，非运行时行为**：发现循环依赖时立即编译错误，要求程序员手动打破循环
    - 检测算法：构建有向图，使用 DFS 或 Tarjan 算法检测强连通分量
- **打破循环的方法**：
    - 将共享功能提取到独立的子目录模块中（如 `common/`）
    - 所有模块都引用 `common` 模块，而不是相互引用
    - 示例：`main` 和 `std.io` 都引用 `common.helper`，而不是相互引用
- **模块可见性规则**：
    - **未 export 的项严格私有**：未标记 `export` 的项仅在模块内可见，其他模块无法访问
    - 所有模块引用都是显式的，需要通过 `use` 导入
- **模块初始化**：
    - **v1.4 明确不支持模块初始化**（如 `init` 函数）
    - 保持"零运行时开销"承诺，所有模块解析在编译期完成
- **编译期解析规则**：
    - 所有模块路径在编译期解析，零运行时开销
    - 模块依赖关系在编译期构建，用于循环依赖检测
- 与现有特性的兼容性
- 模块路径必须相对于项目根目录（包含 main 函数的目录）

### 3. 需要更新的现有章节

#### 3.1 更新"## 1 文件与词法"

- 添加模块相关的说明
- 说明目录与模块的关系
- 说明目录下的文件如何组织

#### 3.2 更新"## 0.13 核心特性"

- 添加模块系统作为核心特性（如果需要）

#### 3.3 更新"## 28 未实现/将来"

- 将模块系统从"未实现"移到已实现部分

### 4. 关键字更新

在"## 1 文件与词法"的关键字列表中添加：

- `export`（如果尚未列出）
- `use`（如果尚未列出）
- **注意**：`mod` 关键字不在 v1.4 中引入（仅支持目录级模块，符合零新关键字哲学）

### 5. 示例代码

需要包含的示例：

- 基础模块定义和导出
- 模块导入和使用
- 路径式导入
- 别名导入
- 嵌套模块路径
- 多文件项目结构示例
- **FFI 导出/导入示例**：
- 在 `std/io/` 目录中的文件导出 FFI 函数：`export extern i32 printf(byte* fmt, ...);`
- 在其他模块中导入并使用：`use std.io.printf;`
- **FFI 结构体导出示例**（带类型限制说明）：
  - `export extern struct CPoint { x: f64, y: f64 };` ✅ 允许（字段类型为 C 兼容类型）
  - `export extern struct CInvalid { data: [i32; 10] };` ❌ 编译错误（数组类型不是 C 兼容类型）
  - `export extern struct CInvalid2 { writer: IWriter };` ❌ 编译错误（接口类型不是 C 兼容类型）
- **目录结构示例**（相对于项目根目录）：
- 项目根目录（包含 main 函数）→ `main` 模块
- 项目根目录下的 `std/io/` → `std.io` 模块
- 项目根目录下的 `math/utils/` → `math.utils` 模块
- 展示目录结构如何映射到模块路径
- 展示根目录模块（main）的使用方式
- 说明所有路径都相对于项目根目录
- **模块间引用示例**（相对于项目根目录）：
- ✅ 根目录模块引用子目录模块：在 `main.uya` 中使用 `use std.io;`
- ✅ 子目录模块间相互引用：在 `math/utils/calc.uya` 中使用 `use std.io;`
- ✅ 子目录模块引用根目录模块：在 `std/io/file.uya` 中使用 `use main.helper;`（允许，但需避免循环）
- **多文件同模块示例**：
  - `std/io/file.uya` 和 `std/io/print.uya` 都属于 `std.io` 模块
  - 两个文件中的 `export` 项都可以被其他模块访问
  - 两个文件中的非 `export` 项仅在 `std.io` 模块内可见
- **循环依赖检测示例**：
- 如果 `main.uya` 引用 `std.io`，`std.io` 引用 `main.helper`：
- 编译器检测到循环依赖：`main` → `std.io` → `main`
- 编译错误，要求打破循环
- **避免循环依赖的示例**：
- 将 `helper` 提取到 `common/helper.uya`
- 在 `std/io/file.uya` 中使用 `use common.helper;`
- 在 `main.uya` 中也使用 `use common.helper;`
- 这样 `main` 和 `std.io` 都引用 `common`，不会形成循环
- 所有路径都相对于项目根目录解析

## 实现步骤

1. 在 `uya.md` 中确定新章节的插入位置
2. 编写完整的模块系统章节（包含所有子节）
3. 更新现有章节中的相关引用
4. 更新关键字列表（添加 `export` 和 `use`，不添加 `mod`）
5. 添加完整的示例代码
6. 确保与现有规范的一致性

## 注意事项

- **保持与 Uya 语言设计哲学一致**：
  - 零新关键字：v1.4 不引入 `mod` 关键字，仅使用 `export` 和 `use`
  - 编译期展开：所有模块解析在编译期完成
  - 零运行时开销：无模块初始化，无运行时模块加载
- **v1.4 核心设计原则**：
  - 所有路径绝对相对于项目根目录
  - 循环依赖是编译错误，非运行时行为
  - 未 export 的项严格私有
  - 不支持通配符导入（避免命名污染）
  - 不支持块级模块（仅目录级模块）
- **确保语法简洁明了**，符合"单页纸可读完"的原则
- **与现有特性保持兼容**（接口、泛型、错误处理等）
- **提供清晰的示例和说明**，覆盖边界情况：
  - 子目录中 `use main.xxx;`
  - 多文件同模块（如 `std/io/file.uya` + `std/io/print.uya` 共享 `std.io` 模块）
  - FFI 导出在子模块中使用
  - 循环依赖检测和打破方法